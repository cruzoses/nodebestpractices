# Розрізняйте операційні та програмні помилки

### Пояснення за один абзац

Розрізнення наступних двох типів помилок мінімізує час простою вашої програми та допоможе уникнути божевільних помилок: Операційні помилки стосуються ситуацій, коли ви розумієте, що сталося та наслідки цього – наприклад, запит до деякої служби HTTP не вдалося виконати через проблему з’єднання. З іншого боку, помилки програміста стосуються випадків, коли ви не знаєте, чому, а іноді й звідки виникла помилка – це може бути якийсь код, який намагався прочитати невизначене значення, або пул з’єднань БД, який пропускає пам’ять. Операційні помилки порівняно легко усунути – зазвичай достатньо зареєструвати помилку. Коли з’являється помилка програміста, програма може перебувати в неузгодженому стані, і немає нічого кращого, ніж просто перезапустити

### Приклад коду – позначення помилки як операційної (довіреної)

<details>
<summary><strong>Javascript</strong></summary>

```javascript
// позначення об'єкта помилки як операційного 
const myError = new Error('Як я можу додати новий продукт, якщо значення не вказано?');
myError.isOperational = true;

// або якщо ви використовуєте централізовану фабрику помилок (див. інші приклади в пункті «Використовуйте лише вбудований об’єкт Error»)
class AppError {
  constructor (commonType, description, isOperational) {
    Error.call(this);
    Error.captureStackTrace(this);
    this.commonType = commonType;
    this.description = description;
    this.isOperational = isOperational;
  }
};

throw new AppError(errorManagement.commonErrors.InvalidInput, 'Опишіть тут, що сталося', true);

```
</details>

<details>
<summary><strong>Typescript</strong></summary>

```typescript
// деяка централізована фабрика помилок (див. інші приклади в пункті «Використовувати лише вбудований об’єкт Error»)
export class AppError extends Error {
  public readonly commonType: string;
  public readonly isOperational: boolean;

  constructor(commonType: string, description: string, isOperational: boolean) {
    super(description);

    Object.setPrototypeOf(this, new.target.prototype); // відновити ланцюжок прототипів

    this.commonType = commonType;
    this.isOperational = isOperational;

    Error.captureStackTrace(this);
  }
}

// позначення об'єкта помилки як операційного (true)
throw new AppError(errorManagement.commonErrors.InvalidInput, 'Опишіть тут, що сталося', true);

```
</details>

### Цитата з блогу: "Помилки програміста - це баги в програмі"

У блозі Joyent отримав 1 місце за ключовими словами «обробка помилок Node.js»

 > …Найкращий спосіб усунути помилки програміста — негайно завершити роботу. Ви повинні запускати свої програми за допомогою перезавантажувача, який автоматично перезапустить програму у разі збою. З перезапуском на місці збій є найшвидшим способом відновити надійне обслуговування в умовах тимчасової помилки програміста…

### Цитата з блогу: "Немає безпечного способу піти, не створивши деякого невизначеного крихкого стану"

З офіційної документації Node.js

 > …Через саму природу роботи throw у JavaScript майже ніколи не існує способу безпечно «продовжити з того місця, де ви зупинилися», без витоку посилань або створення будь-якого іншого типу невизначеного крихкого стану. Найбезпечніший спосіб відповісти на викинуту помилку – це закрити процес. Звичайно, на звичайному веб-сервері у вас може бути багато відкритих з’єднань, і нерозумно різко вимикати їх через те, що помилку спричинив хтось інший. Кращий підхід полягає в тому, щоб надіслати відповідь про помилку на запит, який ініціював помилку, дозволивши іншим завершити роботу у звичайний час, і припинити прослуховування нових запитів у цьому робочому файлі.

### Цитата з блогу: "Інакше ви ризикуєте погіршити стан вашої програми"

У блозі debugable.com отримав 3 місце за ключовими словами «Node.js uncaught exception»

 > …Отже, якщо ви дійсно не знаєте, що робите, вам слід виконати акуратний перезапуск вашої служби після отримання виняткової події «uncaughtException». Інакше ви ризикуєте, що стан вашої програми або бібліотек сторонніх розробників стане непослідовним, що призведе до різноманітних божевільних помилок…

### Цитата з блогу: "Існує три школи думок щодо обробки помилок"

З блогу: JS Recipes

> …Існують перш за все три школи думок щодо обробки помилок:
>1. Дозвольте програмі завершити роботу та перезапустіть її.
>2. Обробляйте всі можливі помилки та ніколи не виходьте з ладу.
>3. Збалансований підхід між ними
