# Вловлювання необроблених відхилень промісів

### Пояснення за один абзац

Зазвичай, більша частина коду сучасних додатків Node.js/Express виконується у межах промісів – чи то в рамках обробника .then, зворотного виклику функції або у блоку catch. Дивно, але якщо розробник забуває додати .catch, помилки, кинуті в цих місцях, не обробляються подією uncaughtException і зникають. Нещодавні версії Node запровадили повідомлення про попередження, коли з'являється необроблене відхилення, хоча це й може допомогти помітити, коли щось пішло не так, але це очевидно не належний метод обробки помилок. Просте рішення – ніколи не забувати додавати .catch в кожен виклик ланцюга промісів та перенаправляти їх до централізованого обробника помилок. Однак, побудова стратегії обробки помилок тільки на дисципліні розробників є дещо крихкою. Тому настійно рекомендується використовувати елегантне відступне рішення та підписатись на `process.on('unhandledRejection', callback)` – це гарантує, що будь-яка помилка проміса, якщо її не оброблено локально, буде відповідно оброблена.

### Приклад коду: ці помилки не будуть піймані жодним обробником помилок (крім unhandledRejection)

```javascript
DAL.getUserById(1).then((johnSnow) => {
  // ця помилка просто зникне
  if(johnSnow.isAlive === false)
      throw new Error('ahhhh');
});
```

### Приклад коду: Вловлювання нерозв'язаних та відхилених промісів

<details>
<summary><strong>Javascript</strong></summary>

```javascript
process.on('unhandledRejection', (reason, p) => {
  // Я щойно піймав необроблене відхилення проміса,
  // оскільки у нас вже є відступний обробник для необроблених помилок (дивіться нижче),
  // давайте кинемо його та дозволимо йому впоратися з цим
  throw reason;
});

process.on('uncaughtException', (error) => {
  // Я щойно отримав помилку, яка ніколи не була оброблена, час впоратися з нею, а потім вирішити, чи потрібен перезапуск
  errorManagement.handler.handleError(error);
  if (!errorManagement.handler.isTrustedError(error))
    process.exit(1);
});
```
</details>

<details>
<summary><strong>Typescript</strong></summary>

```typescript
process.on('unhandledRejection', (reason: string, p: Promise<any>) => {
  // Я щойно піймав необроблене відхилення проміса,
  // оскільки у нас вже є відступний обробник для необроблених помилок (дивіться нижче),
  // давайте кинемо його та дозволимо йому впоратися з цим
  throw reason;
});

process.on('uncaughtException', (error: Error) => {
  // Я щойно отримав помилку, яка ніколи не була оброблена, час впоратися з нею, а потім вирішити, чи потрібен перезапуск
  errorManagement.handler.handleError(error);
  if (!errorManagement.handler.isTrustedError(error))
    process.exit(1);
});
```
</details>

### Цитата з блогу: "Якщо ви можете зробити помилку, то в якийсь момент ви її зробите"

З блогу Джеймса Нельсона

> Давайте перевіримо ваше розуміння. Які з наступних варіантів, на вашу думку, мають вивести помилку в консоль?

```javascript
Promise.resolve('обіцяне значення').then(() => {
  throw new Error('помилка');
});

Promise.reject('значення помилки').catch(() => {
  throw new Error('помилка');
});

new Promise((resolve, reject) => {
  throw new Error('помилка');
});
```

> Не знаю як ви, але я очікував би, що всі вони виведуть помилку. Однак, насправді, багато сучасних JavaScript-середовищ не виведуть помилки для жодного з них. Проблема з тим, що бути людиною означає, що якщо ви можете зробити помилку, то в якийсь момент ви її зробите. За таких обставин здається очевидним, що ми повинні проектувати речі таким чином, щоб помилки завдавали якомога менше шкоди, і це означає обробку помилок за замовчуванням, а не їх відкидання.